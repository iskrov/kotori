# [10-2] Implement Gemini integration service

## Description

Build a service that integrates with Google's Gemini API to map journal entries to template questions and generate appropriate answers. The service will also handle translation to the target language while maintaining context and meaning.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-01-27 14:50:00 | Created | N/A | Proposed | Task created | ai-agent |

## Requirements

### Functional Requirements
- Connect to Google Gemini API using API key from Secret Manager
- Map journal entry content to template questions
- Generate concise, relevant answers (100-200 words per question)
- Translate complete Q&A pairs to target language
- Handle rate limiting and retries

### Technical Requirements
- Use google-generativeai Python SDK
- Implement prompt engineering for consistent results
- Cache responses to reduce API calls
- Structured logging for debugging
- Error handling with fallbacks

## Implementation Plan

### 1. Gemini Service Setup (1 hour)

```python
# backend/app/services/gemini_service.py

import google.generativeai as genai
from typing import List, Dict, Optional
import json

class GeminiService:
    def __init__(self):
        self.model = None
        self.initialize_client()
    
    def initialize_client(self):
        """Initialize Gemini client with API key from settings"""
        api_key = settings.GEMINI_API_KEY
        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel('gemini-pro')
    
    async def map_entries_to_questions(
        self,
        entries: List[Dict],
        questions: List[Dict],
        target_language: str = "en"
    ) -> Dict[str, str]:
        """Map journal entries to template questions and generate answers"""
        pass
```

### 2. Prompt Engineering (2 hours)

```python
def create_mapping_prompt(self, entries, questions, target_lang):
    """Create optimized prompt for Q&A generation"""
    
    prompt = f"""
    You are a helpful assistant that creates summaries for healthcare sharing.
    
    JOURNAL ENTRIES:
    {json.dumps(entries, indent=2)}
    
    QUESTIONS TO ANSWER:
    {json.dumps(questions, indent=2)}
    
    INSTRUCTIONS:
    1. Read the journal entries carefully
    2. For each question, find relevant information from the entries
    3. Generate a concise answer (100-200 words) based on the entries
    4. If no relevant information exists, respond with "No information available"
    5. Translate the final Q&A pairs to {target_lang}
    6. Maintain a supportive, professional tone
    
    OUTPUT FORMAT (JSON):
    {{
        "answers": [
            {{
                "question_id": "mood",
                "question_text": "translated question",
                "answer": "translated answer",
                "confidence": 0.95
            }}
        ],
        "source_language": "en",
        "target_language": "{target_lang}"
    }}
    """
    return prompt
```

### 3. API Integration (1 hour)

```python
async def process_share_request(
    self,
    entries: List[Dict],
    template: Dict,
    target_language: str
) -> ShareSummary:
    """Main processing function"""
    
    try:
        # Prepare entries (remove PII if needed)
        cleaned_entries = self.prepare_entries(entries)
        
        # Create prompt
        prompt = self.create_mapping_prompt(
            cleaned_entries,
            template['questions'],
            target_language
        )
        
        # Call Gemini API
        response = await self.model.generate_content_async(
            prompt,
            generation_config=genai.GenerationConfig(
                temperature=0.7,
                max_output_tokens=2000,
            )
        )
        
        # Parse response
        result = json.loads(response.text)
        
        # Validate and return
        return self.validate_response(result)
        
    except Exception as e:
        logger.error(f"Gemini processing failed: {e}")
        raise
```

### 4. Rate Limiting & Caching (30 mins)

```python
from functools import lru_cache
import hashlib

class GeminiRateLimiter:
    def __init__(self, requests_per_minute=60):
        self.rpm = requests_per_minute
        self.request_times = []
    
    async def check_rate_limit(self):
        """Implement token bucket algorithm"""
        pass

@lru_cache(maxsize=100)
def cache_key(entries_hash: str, template_id: str, language: str):
    """Generate cache key for responses"""
    return hashlib.sha256(
        f"{entries_hash}:{template_id}:{language}".encode()
    ).hexdigest()
```

### 5. Error Handling (30 mins)

```python
class GeminiError(Exception):
    """Base exception for Gemini service"""
    pass

class GeminiRateLimitError(GeminiError):
    """Rate limit exceeded"""
    pass

class GeminiInvalidResponseError(GeminiError):
    """Invalid response format from API"""
    pass

async def with_retry(func, max_retries=3, backoff=2):
    """Exponential backoff retry logic"""
    for attempt in range(max_retries):
        try:
            return await func()
        except GeminiRateLimitError:
            wait_time = backoff ** attempt
            await asyncio.sleep(wait_time)
    raise
```

## Verification

### Unit Tests
- Prompt generation with various inputs
- Response parsing and validation
- Error handling scenarios
- Cache functionality

### Integration Tests
- Actual API calls with test data
- Rate limiting behavior
- Translation accuracy spot checks
- Timeout handling

### Manual Testing
- Process real journal entries
- Verify answer relevance
- Check translation quality
- Test with multiple languages

## Files Modified

### New Files
- `backend/app/services/gemini_service.py`
- `backend/app/services/gemini_prompts.py`
- `backend/tests/services/test_gemini_service.py`

### Modified Files
- `backend/app/core/config.py` (add GEMINI_API_KEY)
- `backend/requirements.txt` (add google-generativeai)
- `.env.example` (add GEMINI_API_KEY placeholder)

## Estimated Time

- Total: 4.5 hours
- Service setup: 1 hour
- Prompt engineering: 2 hours
- Integration & testing: 1 hour
- Error handling: 30 minutes

## Dependencies

- Task 10-1 (templates must exist)
- Google Cloud project with Gemini API enabled
- API key in Secret Manager

## Notes

- Start with conservative rate limits
- Monitor API costs closely
- Consider implementing usage quotas per user
- Prompt versioning for A/B testing
- May need to chunk large entry sets

## Risk Mitigation

- Fallback to simpler prompts if complex ones fail
- Cache aggressively to reduce API calls
- Implement cost alerts in GCP
- Test with various entry lengths and languages

[Back to task list](./tasks.md)
