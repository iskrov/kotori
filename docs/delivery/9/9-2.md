# [9-2] Implement database constraints and indexes

[Back to task list](./tasks.md)

## Description

Implement comprehensive database constraints and indexes to ensure data integrity, enforce business logic rules, and optimize query performance. This task builds on the UUID schema migration to create a robust, performant database layer.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-01-22 12:00:00 | Created | N/A | Proposed | Task file created | AI Agent |
| 2025-01-22 14:00:00 | Status Update | Proposed | Agreed | Task approved for implementation | User |
| 2025-01-22 14:30:00 | Status Update | Agreed | InProgress | Started database constraints and indexes implementation | AI Agent |
| 2025-01-22 15:00:00 | Status Update | InProgress | Review | Database constraints and indexes completed | AI Agent |
| 2025-01-22 15:30:00 | Status Update | Review | Done | Constraints and indexes validated and accepted | User |

## Requirements

### Core Index Requirements
- Create indexes on all foreign key columns for performance
- Implement composite indexes for common query patterns
- Add unique constraints where appropriate
- Ensure optimal index strategy for UUID columns

### Specific Index Requirements

1. **Foreign Key Indexes**
   - `journal_entries.user_id` - Index for user's journal entries
   - `tags.user_id` - Index for user's tags
   - `reminders.user_id` - Index for user's reminders
   - `secret_tags.user_id` - Index for user's secret tags

2. **Composite Indexes**
   - `(user_id, created_at)` - For chronological queries
   - `(user_id, updated_at)` - For recent activity queries
   - `(user_id, title)` - For title-based searches

3. **Unique Constraints**
   - `users.email` - Ensure email uniqueness
   - `(user_id, tag_name)` - Prevent duplicate tags per user
   - `secret_tags.phrase_hash` - Ensure unique phrase hashes for OPAQUE lookups

### Business Logic Constraints
- NOT NULL constraints on required fields
- CHECK constraints for data validation
- Foreign key constraints with proper CASCADE rules
- Unique constraints for business rules

## Implementation Plan

### Phase 1: Index Analysis and Design
1. **Query Pattern Analysis**
   - Identify common query patterns from API endpoints
   - Analyze JOIN operations and filtering conditions
   - Review sorting and pagination requirements

2. **Index Strategy Design**
   - Design foreign key indexes for performance
   - Plan composite indexes for complex queries
   - Consider index maintenance overhead

### Phase 2: Foreign Key Index Implementation
1. **Create Foreign Key Indexes**
   ```sql
   CREATE INDEX idx_journal_entries_user_id ON journal_entries(user_id);
   CREATE INDEX idx_tags_user_id ON tags(user_id);
   CREATE INDEX idx_reminders_user_id ON reminders(user_id);
   CREATE INDEX idx_secret_tags_user_id ON secret_tags(user_id);
   CREATE UNIQUE INDEX idx_secret_tags_phrase_hash ON secret_tags(phrase_hash);
   ```

2. **Validate Index Usage**
   - Use EXPLAIN ANALYZE to verify index usage
   - Test query performance improvements
   - Monitor index maintenance overhead

### Phase 3: Composite Index Implementation
1. **Chronological Query Indexes**
   ```sql
   CREATE INDEX idx_journal_entries_user_created ON journal_entries(user_id, created_at DESC);
   CREATE INDEX idx_tags_user_created ON tags(user_id, created_at DESC);
   CREATE INDEX idx_secret_tags_user_created ON secret_tags(user_id, created_at DESC);
   ```

2. **Search and Filter Indexes**
   ```sql
   CREATE INDEX idx_journal_entries_user_title ON journal_entries(user_id, title);
   CREATE INDEX idx_tags_user_name ON tags(user_id, name);
   CREATE INDEX idx_secret_tags_user_name ON secret_tags(user_id, tag_name);
   ```

### Phase 4: Constraint Implementation
1. **Business Logic Constraints**
   ```sql
   ALTER TABLE users ADD CONSTRAINT unique_email UNIQUE (email);
   ALTER TABLE tags ADD CONSTRAINT unique_user_tag UNIQUE (user_id, name);
   ALTER TABLE secret_tags ADD CONSTRAINT unique_user_secret_tag UNIQUE (user_id, tag_name);
   ```

2. **Data Validation Constraints**
   - Add CHECK constraints for data ranges
   - Implement NOT NULL constraints on required fields
   - Add foreign key constraints with CASCADE rules

## Test Plan

### Objective
Verify that all indexes and constraints are properly implemented and provide expected performance improvements while maintaining data integrity.

### Test Environment
- Local development database (PostgreSQL 14+)
- Test database with sample data
- Query performance monitoring tools

### Key Test Scenarios

1. **Index Performance Testing**
   - Query execution time before and after index creation
   - EXPLAIN ANALYZE output shows index usage
   - JOIN operations use appropriate indexes
   - Sorting and filtering operations are optimized

2. **Constraint Validation**
   - Unique constraints prevent duplicate data
   - Foreign key constraints maintain referential integrity
   - CHECK constraints validate data ranges
   - NOT NULL constraints enforce required fields

3. **Edge Case Testing**
   - Large dataset performance testing
   - Concurrent operation handling
   - Index maintenance during bulk operations
   - Constraint violation error handling

### Success Criteria
- All foreign key queries use indexes (verified with EXPLAIN ANALYZE)
- Query performance meets or exceeds baseline requirements
- All constraints properly enforce business logic
- No false positive or negative constraint violations
- Index maintenance overhead is acceptable

## Verification

### Completion Checklist
- [ ] Foreign key indexes created for all relationships
- [ ] Composite indexes created for common query patterns
- [ ] Unique constraints implemented for business rules
- [ ] Performance testing validates index effectiveness
- [ ] Constraint testing validates data integrity
- [ ] Documentation updated with index strategy

### Technical Validation
- [ ] `EXPLAIN ANALYZE` shows index usage for all critical queries
- [ ] Query execution times meet performance requirements
- [ ] All constraint violations properly handled
- [ ] Index maintenance overhead is within acceptable limits
- [ ] Database statistics updated after index creation

### Files Modified
- `backend/alembic/versions/` - Migration file with index creation
- `backend/app/models/` - Model definitions with constraints
- `docs/technical/` - Index strategy documentation

## Implementation Notes

### PostgreSQL-Specific Considerations
1. **UUID Index Performance**: Use proper index types for UUID columns
2. **Index Maintenance**: Consider VACUUM and ANALYZE scheduling
3. **Composite Index Order**: Column order matters for query optimization
4. **Partial Indexes**: Consider for filtered queries on large tables

### Index Strategy Guidelines
1. **Primary Indexes**: Always index foreign keys
2. **Composite Indexes**: Order by selectivity (most selective first)
3. **Unique Indexes**: Implement for business logic constraints
4. **Covering Indexes**: Consider for frequently accessed columns

### Dependencies
- Completion of Task 9-1 (UUID schema migration)
- PostgreSQL 14+ with UUID support
- Sample data for performance testing
- Query monitoring tools

### Risk Mitigation
- Test index creation on development database first
- Monitor index maintenance overhead
- Validate constraint logic thoroughly
- Document rollback procedures for index changes 