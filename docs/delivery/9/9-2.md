# [9-2] Implement Google authentication and encryption key derivation

## Description

Currently, Google authentication is only implemented as a test stub that accepts `"test_google_token"` and returns null for real Google ID tokens. This task implements proper Google authentication and addresses the encryption key derivation challenge for Google users who don't have OPAQUE export keys.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-08-12 06:50:00 | Created | N/A | Proposed | Task created for Google authentication | ai-agent |
| 2025-08-16 00:00:00 | Status Change | Proposed | InProgress | Started implementation: backend Google ID verification and config added | ai-agent |

## Requirements

### Functional Requirements
1. Implement real Google ID token verification
2. Create/update users based on Google authentication
3. Provide encryption key derivation strategy for Google users
4. Maintain backward compatibility with existing OPAQUE users
5. Support seamless switching between auth methods

### Technical Requirements
1. Use Google's official token verification library
2. Implement secure key derivation for Google users
3. Handle mixed authentication scenarios (Google + OPAQUE)
4. Provide clear error messages for auth failures
5. Maintain security parity with OPAQUE authentication

## Implementation Plan

### Step 1: Implement Real Google Token Verification

```python
# Update backend/app/services/auth_service.py
from google.auth.transport import requests
from google.oauth2 import id_token
import logging

logger = logging.getLogger(__name__)

class AuthService:
    def authenticate_google(self, db: Session, *, token: str) -> User | None:
        """
        Authenticate a user with a Google ID token.
        Verifies the token with Google and creates/updates user.
        """
        try:
            # Verify the Google ID token
            idinfo = id_token.verify_oauth2_token(
                token, 
                requests.Request(), 
                settings.GOOGLE_CLIENT_ID
            )
            
            # Validate issuer
            if idinfo['iss'] not in ['accounts.google.com', 'https://accounts.google.com']:
                logger.error("Invalid Google token issuer")
                return None
                
            # Extract user info
            google_id = idinfo['sub']
            email = idinfo['email']
            name = idinfo.get('name', '')
            
            # Find or create user
            user = db.query(User).filter(User.google_id == google_id).first()
            
            if not user:
                # Check if user exists with same email but different auth method
                existing_user = db.query(User).filter(User.email == email).first()
                if existing_user and existing_user.opaque_envelope is not None:
                    # User has OPAQUE account - don't allow Google auth
                    logger.warning(f"User {email} has OPAQUE account, cannot use Google auth")
                    return None
                
                # Create new Google user
                user = User(
                    email=email,
                    full_name=name,
                    google_id=google_id,
                    is_active=True,
                    created_at=datetime.now(timezone.utc),
                    updated_at=datetime.now(timezone.utc),
                    # Google users don't have OPAQUE envelope
                    opaque_envelope=None
                )
                db.add(user)
                db.commit()
                db.refresh(user)
                
                logger.info(f"Created new Google user: {email}")
            else:
                # Update existing user info
                user.full_name = name
                user.email = email
                user.updated_at = datetime.now(timezone.utc)
                db.commit()
                
                logger.info(f"Updated existing Google user: {email}")
            
            return user
            
        except ValueError as e:
            logger.error(f"Invalid Google token: {e}")
            return None
        except Exception as e:
            logger.error(f"Google authentication error: {e}", exc_info=True)
            return None
```

### Step 2: Add Google Client Configuration

```python
# Update backend/app/core/config.py
class Settings(BaseSettings):
    # ... existing settings ...
    
    # Google OAuth settings
    GOOGLE_CLIENT_ID: str = Field(..., env="GOOGLE_CLIENT_ID")
    GOOGLE_CLIENT_SECRET: str = Field(..., env="GOOGLE_CLIENT_SECRET")
    
    class Config:
        env_file = ".env"
```

### Step 3: Implement Encryption Key Strategy for Google Users

```typescript
// Update frontend/src/services/clientEncryption.ts
class ClientEncryption {
  private googleUserKey: CryptoKey | null = null;
  
  async getOrCreateMasterKey(user: User): Promise<CryptoKey> {
    if (user.google_id) {
      // Google user - derive key from Google ID + app secret
      return this.getMasterKeyForGoogleUser(user);
    } else {
      // OPAQUE user - use existing logic
      return this.getMasterKeyFromOPAQUE();
    }
  }
  
  private async getMasterKeyForGoogleUser(user: User): Promise<CryptoKey> {
    if (this.googleUserKey) {
      return this.googleUserKey;
    }
    
    try {
      // Option A: Derive from Google ID + stored salt
      const stored = await AsyncStorage.getItem(`google_key_${user.google_id}`);
      
      if (stored) {
        const { salt, keyData } = JSON.parse(stored);
        this.googleUserKey = await this.deriveKeyFromGoogleId(
          user.google_id, 
          this.base64ToArray(salt)
        );
      } else {
        // First time - generate salt and derive key
        const salt = crypto.getRandomValues(new Uint8Array(32));
        this.googleUserKey = await this.deriveKeyFromGoogleId(
          user.google_id, 
          salt
        );
        
        // Store salt for future use
        await AsyncStorage.setItem(`google_key_${user.google_id}`, JSON.stringify({
          salt: this.arrayToBase64(salt),
          created: Date.now()
        }));
      }
      
      return this.googleUserKey;
    } catch (error) {
      logger.error('Failed to derive Google user key', error);
      throw new Error('Key derivation failed');
    }
  }
  
  private async deriveKeyFromGoogleId(
    googleId: string, 
    salt: Uint8Array
  ): Promise<CryptoKey> {
    // Derive key using PBKDF2 with Google ID as password
    const encoder = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey(
      'raw',
      encoder.encode(googleId + process.env.EXPO_PUBLIC_APP_SECRET),
      'PBKDF2',
      false,
      ['deriveKey']
    );
    
    return crypto.subtle.deriveKey(
      {
        name: 'PBKDF2',
        salt: salt,
        iterations: 100000,
        hash: 'SHA-256'
      },
      keyMaterial,
      { name: 'AES-GCM', length: 256 },
      false,
      ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']
    );
  }
}
```

### Step 4: Update Frontend Authentication

```typescript
// Update frontend/src/services/api.ts
export const AuthAPI = {
  // ... existing methods ...
  
  googleSignIn: async (idToken: string) => {
    try {
      const response = await api.post('/api/v1/auth/google', { 
        token: idToken  // Use correct field name
      });
      
      // Store tokens and user info
      if (response.data.access_token) {
        await AsyncStorage.setItem('access_token', response.data.access_token);
        await AsyncStorage.setItem('refresh_token', response.data.refresh_token);
        await AsyncStorage.setItem('user', JSON.stringify(response.data.user));
      }
      
      return response.data;
    } catch (error) {
      logger.error('Google sign-in failed', error);
      throw error;
    }
  }
};
```

### Step 5: Add Mixed Authentication Support

```typescript
// Create frontend/src/services/authStrategy.ts
export class AuthStrategy {
  static async determineAuthMethod(user: User): Promise<'google' | 'opaque'> {
    return user.google_id ? 'google' : 'opaque';
  }
  
  static async canUseEncryption(user: User): Promise<boolean> {
    // Both Google and OPAQUE users can use encryption
    return true;
  }
  
  static async getMasterKey(user: User): Promise<CryptoKey> {
    const authMethod = await this.determineAuthMethod(user);
    
    if (authMethod === 'google') {
      return clientEncryption.getMasterKeyForGoogleUser(user);
    } else {
      return clientEncryption.getMasterKeyFromOPAQUE();
    }
  }
}
```

## Verification

### Test Scenarios
1. **Google Token Verification**: Real Google ID tokens are properly validated
2. **User Creation**: New Google users are created with correct fields
3. **User Updates**: Existing Google users are updated on login
4. **Mixed Auth Prevention**: Users can't switch between Google and OPAQUE
5. **Key Derivation**: Google users get consistent encryption keys
6. **Encryption Flow**: Google users can encrypt/decrypt entries
7. **Cross-Platform**: Works on web, iOS, and Android

### Security Considerations
- Google ID tokens are verified against Google's servers
- Google users get deterministic but secure encryption keys
- Keys are derived from Google ID + app secret (not stored plaintext)
- Salt is stored locally for key consistency
- No cross-contamination between auth methods

### Success Criteria
- [ ] Real Google authentication works end-to-end
- [ ] Google users can create and view encrypted entries
- [ ] Key derivation is consistent across sessions
- [ ] No security regression from OPAQUE authentication
- [ ] Clear error messages for authentication failures
- [ ] Backward compatibility maintained

## Files Modified

Expected files to create/modify:
- `backend/app/services/auth_service.py` (major update)
- `backend/app/core/config.py` (add Google settings)
- `backend/requirements.txt` (add google-auth library)
- `frontend/src/services/clientEncryption.ts` (add Google key derivation)
- `frontend/src/services/authStrategy.ts` (new)
- `frontend/src/services/api.ts` (fix Google auth call)
- `frontend/src/types/user.ts` (ensure Google fields)

## Dependencies

- Google Auth Library for Python: `google-auth>=2.0.0`
- Environment variables: `GOOGLE_CLIENT_ID`, `GOOGLE_CLIENT_SECRET`
- Frontend: Expo Google Sign-In configuration
- App secret for key derivation security

## Notes

This task addresses both the immediate Google authentication issue and the longer-term encryption compatibility. Google users will have a slightly different key derivation path but the same encryption security level as OPAQUE users.

The implementation uses deterministic key derivation so Google users get the same encryption key across devices and sessions, enabling proper decryption of their entries.

[Back to task list](./tasks.md)
