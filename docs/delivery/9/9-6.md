# [9-6] Add key persistence and recovery mechanisms

## Description

Implement robust key persistence and recovery mechanisms to ensure users don't lose access to their encrypted entries. This includes secure storage of master keys, key backup strategies, and recovery flows for various failure scenarios.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-08-12 03:35:00 | Created | N/A | Proposed | Task created for key management | ai-agent |

## Requirements

### Functional Requirements
1. Persist master keys securely across app sessions
2. Automatic key recovery from OPAQUE session
3. Key backup and restore mechanisms
4. Multi-device key synchronization (future)
5. Key rotation capabilities

### Technical Requirements
1. Use platform-specific secure storage (Keychain/Keystore)
2. Implement key versioning
3. Support key migration for updates
4. Encrypted key backup format
5. Key derivation audit trail

## Implementation Plan

### Step 1: Implement Secure Key Storage
```typescript
// Create new file: frontend/src/services/secureKeyStorage.ts
import * as SecureStore from 'expo-secure-store';
import AsyncStorage from '@react-native-async-storage/async-storage';

class SecureKeyStorage {
  private readonly MASTER_KEY = 'kotori_master_key_v1';
  private readonly KEY_METADATA = 'kotori_key_metadata_v1';
  private readonly KEY_BACKUP = 'kotori_key_backup_v1';
  
  async storeMasterKey(
    key: CryptoKey,
    metadata: KeyMetadata
  ): Promise<void> {
    try {
      // Export the key
      const exported = await crypto.subtle.exportKey('raw', key);
      const keyBytes = new Uint8Array(exported);
      const keyBase64 = this.arrayToBase64(keyBytes);
      
      // Store in secure storage (platform-specific)
      if (this.isSecureStorageAvailable()) {
        await SecureStore.setItemAsync(this.MASTER_KEY, keyBase64);
      } else {
        // Fallback to AsyncStorage with additional encryption
        const encryptedKey = await this.encryptForStorage(keyBase64);
        await AsyncStorage.setItem(this.MASTER_KEY, encryptedKey);
      }
      
      // Store metadata separately
      await AsyncStorage.setItem(
        this.KEY_METADATA,
        JSON.stringify({
          ...metadata,
          storedAt: Date.now(),
          version: 1
        })
      );
      
      logger.info('Master key stored securely');
    } catch (error) {
      logger.error('Failed to store master key', error);
      throw new Error('Key storage failed');
    }
  }
  
  async retrieveMasterKey(): Promise<{
    key: CryptoKey;
    metadata: KeyMetadata;
  } | null> {
    try {
      let keyBase64: string | null = null;
      
      // Retrieve from secure storage
      if (this.isSecureStorageAvailable()) {
        keyBase64 = await SecureStore.getItemAsync(this.MASTER_KEY);
      } else {
        const encrypted = await AsyncStorage.getItem(this.MASTER_KEY);
        if (encrypted) {
          keyBase64 = await this.decryptFromStorage(encrypted);
        }
      }
      
      if (!keyBase64) {
        return null;
      }
      
      // Import the key
      const keyBytes = this.base64ToArray(keyBase64);
      const key = await crypto.subtle.importKey(
        'raw',
        keyBytes,
        { name: 'AES-GCM', length: 256 },
        false,
        ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']
      );
      
      // Get metadata
      const metadataStr = await AsyncStorage.getItem(this.KEY_METADATA);
      const metadata = metadataStr ? JSON.parse(metadataStr) : {};
      
      return { key, metadata };
    } catch (error) {
      logger.error('Failed to retrieve master key', error);
      return null;
    }
  }
  
  private isSecureStorageAvailable(): boolean {
    // Check if running on mobile with secure storage
    return Platform.OS !== 'web' && SecureStore.isAvailableAsync();
  }
}
```

### Step 2: Implement Key Recovery from OPAQUE
```typescript
// Update clientEncryption.ts
class KeyRecoveryService {
  private readonly MAX_RECOVERY_ATTEMPTS = 3;
  private recoveryAttempts = 0;
  
  async recoverFromOPAQUE(): Promise<CryptoKey | null> {
    try {
      // Get OPAQUE export key from current session
      const opaqueSession = await this.getOPAQUESession();
      if (!opaqueSession || !opaqueSession.export_key) {
        logger.warn('No OPAQUE session available for key recovery');
        return null;
      }
      
      // Derive master key from export key
      const exportKey = this.base64ToArray(opaqueSession.export_key);
      const masterKey = await this.deriveMasterKeyFromExport(exportKey);
      
      // Verify the key works by testing with a known encrypted entry
      const isValid = await this.verifyMasterKey(masterKey);
      if (!isValid) {
        logger.error('Recovered key failed verification');
        return null;
      }
      
      // Store the recovered key
      await secureKeyStorage.storeMasterKey(masterKey, {
        source: 'OPAQUE_RECOVERY',
        timestamp: Date.now(),
        sessionId: opaqueSession.session_id
      });
      
      logger.info('Successfully recovered master key from OPAQUE');
      return masterKey;
    } catch (error) {
      logger.error('OPAQUE key recovery failed', error);
      this.recoveryAttempts++;
      
      if (this.recoveryAttempts < this.MAX_RECOVERY_ATTEMPTS) {
        // Retry with exponential backoff
        await this.delay(Math.pow(2, this.recoveryAttempts) * 1000);
        return this.recoverFromOPAQUE();
      }
      
      return null;
    }
  }
  
  private async verifyMasterKey(key: CryptoKey): Promise<boolean> {
    try {
      // Try to decrypt a test value or a known encrypted entry
      const testData = await AsyncStorage.getItem('key_verification_test');
      if (testData) {
        const { encrypted, iv } = JSON.parse(testData);
        const decrypted = await crypto.subtle.decrypt(
          { name: 'AES-GCM', iv: this.base64ToArray(iv) },
          key,
          this.base64ToArray(encrypted)
        );
        return true;
      }
      
      // If no test data, create one for future verifications
      await this.createVerificationData(key);
      return true;
    } catch (error) {
      return false;
    }
  }
}
```

### Step 3: Implement Key Backup System
```typescript
// Add key backup functionality
class KeyBackupService {
  async createBackup(
    masterKey: CryptoKey,
    backupPassword?: string
  ): Promise<string> {
    try {
      // Export the master key
      const exported = await crypto.subtle.exportKey('raw', masterKey);
      const keyBytes = new Uint8Array(exported);
      
      // Create backup structure
      const backup: KeyBackup = {
        version: 1,
        timestamp: Date.now(),
        keyData: this.arrayToBase64(keyBytes),
        metadata: {
          app_version: Constants.manifest?.version,
          platform: Platform.OS,
          device_id: await this.getDeviceId()
        }
      };
      
      // Optionally encrypt with password
      if (backupPassword) {
        const encrypted = await this.encryptBackup(backup, backupPassword);
        return encrypted;
      }
      
      // Return base64 encoded backup
      return btoa(JSON.stringify(backup));
    } catch (error) {
      logger.error('Failed to create key backup', error);
      throw new Error('Backup creation failed');
    }
  }
  
  async restoreFromBackup(
    backupData: string,
    backupPassword?: string
  ): Promise<CryptoKey> {
    try {
      let backup: KeyBackup;
      
      // Decrypt if password provided
      if (backupPassword) {
        backup = await this.decryptBackup(backupData, backupPassword);
      } else {
        backup = JSON.parse(atob(backupData));
      }
      
      // Validate backup
      if (!this.validateBackup(backup)) {
        throw new Error('Invalid backup format');
      }
      
      // Import the key
      const keyBytes = this.base64ToArray(backup.keyData);
      const masterKey = await crypto.subtle.importKey(
        'raw',
        keyBytes,
        { name: 'AES-GCM', length: 256 },
        false,
        ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']
      );
      
      // Store the restored key
      await secureKeyStorage.storeMasterKey(masterKey, {
        source: 'BACKUP_RESTORE',
        timestamp: Date.now(),
        backup_timestamp: backup.timestamp
      });
      
      logger.info('Successfully restored key from backup');
      return masterKey;
    } catch (error) {
      logger.error('Failed to restore from backup', error);
      throw new Error('Backup restoration failed');
    }
  }
  
  private async encryptBackup(
    backup: KeyBackup,
    password: string
  ): Promise<string> {
    // Derive key from password using PBKDF2
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const passwordKey = await this.deriveKeyFromPassword(password, salt);
    
    // Encrypt backup
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encrypted = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv },
      passwordKey,
      new TextEncoder().encode(JSON.stringify(backup))
    );
    
    // Return encrypted backup with metadata
    return btoa(JSON.stringify({
      encrypted: this.arrayToBase64(new Uint8Array(encrypted)),
      salt: this.arrayToBase64(salt),
      iv: this.arrayToBase64(iv),
      version: 1
    }));
  }
}
```

### Step 4: Implement Key Rotation
```typescript
// Add key rotation capability
class KeyRotationService {
  async rotateKeys(): Promise<void> {
    try {
      logger.info('Starting key rotation');
      
      // Generate new master key
      const newMasterKey = await crypto.subtle.generateKey(
        { name: 'AES-GCM', length: 256 },
        true,
        ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']
      );
      
      // Get all encrypted entries
      const entries = await this.getAllEncryptedEntries();
      
      // Re-encrypt with new key
      const reencrypted = await this.reencryptEntries(
        entries,
        newMasterKey
      );
      
      // Update all entries in batch
      await this.updateEntriesInBatch(reencrypted);
      
      // Store new master key
      await secureKeyStorage.storeMasterKey(newMasterKey, {
        source: 'KEY_ROTATION',
        timestamp: Date.now(),
        previous_key_hash: await this.hashKey(this.currentMasterKey)
      });
      
      // Keep old key for recovery (encrypted)
      await this.archiveOldKey(this.currentMasterKey);
      
      logger.info('Key rotation completed successfully');
    } catch (error) {
      logger.error('Key rotation failed', error);
      throw new Error('Key rotation failed - entries may be inconsistent');
    }
  }
  
  private async reencryptEntries(
    entries: EncryptedEntry[],
    newMasterKey: CryptoKey
  ): Promise<EncryptedEntry[]> {
    const results = [];
    
    for (const entry of entries) {
      try {
        // Decrypt with old key
        const decrypted = await this.decryptWithCurrentKey(entry);
        
        // Re-encrypt with new key
        const reencrypted = await this.encryptWithKey(
          decrypted,
          newMasterKey
        );
        
        results.push({
          ...entry,
          ...reencrypted,
          key_version: 2
        });
      } catch (error) {
        logger.error(`Failed to rotate key for entry ${entry.id}`, error);
        throw error;
      }
    }
    
    return results;
  }
}
```

### Step 5: Add Recovery UI
```typescript
// Create recovery UI component
export const KeyRecoveryScreen: React.FC = () => {
  const [recovering, setRecovering] = useState(false);
  const [backupData, setBackupData] = useState('');
  const [password, setPassword] = useState('');
  
  const recoverFromOPAQUE = async () => {
    setRecovering(true);
    try {
      const recovered = await keyRecoveryService.recoverFromOPAQUE();
      if (recovered) {
        Alert.alert('Success', 'Keys recovered from your account');
        navigation.goBack();
      } else {
        Alert.alert('Failed', 'Could not recover keys. Please try backup restore.');
      }
    } finally {
      setRecovering(false);
    }
  };
  
  const restoreFromBackup = async () => {
    if (!backupData) {
      Alert.alert('Error', 'Please enter backup data');
      return;
    }
    
    setRecovering(true);
    try {
      await keyBackupService.restoreFromBackup(backupData, password);
      Alert.alert('Success', 'Keys restored from backup');
      navigation.goBack();
    } catch (error) {
      Alert.alert('Error', 'Failed to restore from backup');
    } finally {
      setRecovering(false);
    }
  };
  
  return (
    <SafeAreaView style={styles.container}>
      <Text style={styles.title}>Key Recovery</Text>
      
      <TouchableOpacity
        style={styles.button}
        onPress={recoverFromOPAQUE}
        disabled={recovering}
      >
        <Text>Recover from Account</Text>
      </TouchableOpacity>
      
      <Text style={styles.separator}>OR</Text>
      
      <TextInput
        style={styles.input}
        placeholder="Paste backup data"
        value={backupData}
        onChangeText={setBackupData}
        multiline
      />
      
      <TextInput
        style={styles.input}
        placeholder="Backup password (if encrypted)"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />
      
      <TouchableOpacity
        style={styles.button}
        onPress={restoreFromBackup}
        disabled={recovering}
      >
        <Text>Restore from Backup</Text>
      </TouchableOpacity>
    </SafeAreaView>
  );
};
```

## Verification

### Test Scenarios
1. Key persistence across app restarts
2. Key recovery after app reinstall
3. OPAQUE session key recovery
4. Backup creation and restoration
5. Key rotation with existing entries
6. Multi-device key synchronization (future)

### Success Criteria
- [ ] Keys persist securely across sessions
- [ ] OPAQUE recovery works reliably
- [ ] Backup/restore process is user-friendly
- [ ] Key rotation doesn't lose data
- [ ] Recovery UI is intuitive

## Files Modified

Expected files to create/modify:
- `frontend/src/services/secureKeyStorage.ts` (new)
- `frontend/src/services/keyRecoveryService.ts` (new)
- `frontend/src/services/keyBackupService.ts` (new)
- `frontend/src/services/keyRotationService.ts` (new)
- `frontend/src/screens/KeyRecoveryScreen.tsx` (new)
- `frontend/src/services/clientEncryption.ts`
- `frontend/src/types/encryption.ts` (new)

## Notes

This task is critical for ensuring users don't lose access to their encrypted data. The implementation must be robust and handle various failure scenarios gracefully. Key management should be transparent to users while providing recovery options when needed.

[Back to task list](./tasks.md)
