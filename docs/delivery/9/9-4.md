# [9-4] Update SQLAlchemy models for UUID primary keys

[Back to task list](./tasks.md)

## Description

Update all SQLAlchemy model definitions to use native UUID primary keys consistently across the application. This task ensures that the application code matches the new database schema and provides a solid foundation for all subsequent UUID-based functionality.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-01-22 12:00:00 | Created | N/A | Proposed | Task file created | AI Agent |
| 2025-01-22 16:00:00 | Status Update | Proposed | Agreed | Task approved for implementation | User |
| 2025-01-22 16:30:00 | Status Update | Agreed | InProgress | Started SQLAlchemy model updates for UUID primary keys | AI Agent |
| 2025-01-22 17:00:00 | Status Update | InProgress | Review | All SQLAlchemy models updated to use UUID primary keys | AI Agent |
| 2025-01-22 17:30:00 | Status Update | Review | Done | Model updates validated and accepted | User |

## Requirements

### Core Model Updates
- Convert all models to use native UUID primary keys
- Update foreign key references to use UUID types
- Maintain existing relationships and constraints
- Ensure consistent UUID generation patterns

### Specific Model Requirements

1. **Journal Entry Model** - Convert from integer to UUID primary key
2. **Tag Model** - Convert from integer to UUID primary key
3. **Reminder Model** - Convert from integer to UUID primary key
4. **User Model** - Verify existing UUID implementation
5. **Monitoring Model** - Verify existing UUID implementation
6. **Secret Tag OPAQUE Model** - Fix type confusion with UUID primary key and `phrase_hash` column

### Code Quality Requirements
- Use consistent UUID type definitions
- Maintain existing TimestampMixin pattern
- Preserve all existing relationships
- Add proper type hints and documentation

## Implementation Plan

### Phase 1: Model Analysis and Planning
1. **Current State Analysis**
   - Review existing model definitions in `backend/app/models/`
   - Document current primary key types and foreign key relationships
   - Identify models that need UUID conversion

2. **UUID Implementation Strategy**
   - Define standard UUID column pattern
   - Plan foreign key relationship updates
   - Ensure consistent UUID generation approach

### Phase 2: Core Model Updates
1. **Journal Entry Model Update**
   ```python
   # Before (integer primary key)
   class JournalEntry(Base, TimestampMixin):
       __tablename__ = "journal_entries"
       
       id = Column(Integer, primary_key=True)
       user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"))
   
   # After (UUID primary key)
   class JournalEntry(Base, TimestampMixin):
       __tablename__ = "journal_entries"
       
       id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
       user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
   ```

2. **Tag Model Update**
   ```python
   # Before (integer primary key)
   class Tag(Base, TimestampMixin):
       __tablename__ = "tags"
       
       id = Column(Integer, primary_key=True)
       user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"))
   
   # After (UUID primary key)
   class Tag(Base, TimestampMixin):
       __tablename__ = "tags"
       
       id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
       user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
   ```

3. **Reminder Model Update**
   ```python
   # Before (integer primary key)
   class Reminder(Base, TimestampMixin):
       __tablename__ = "reminders"
       
       id = Column(Integer, primary_key=True)
       user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"))
   
   # After (UUID primary key)
   class Reminder(Base, TimestampMixin):
       __tablename__ = "reminders"
       
       id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
       user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
   ```

4. **Secret Tag Model Fix**
   ```python
   # Before (type confusion - binary data in String field)
   class SecretTag(Base, TimestampMixin):
       __tablename__ = "secret_tags"
       
       tag_id = Column(String(36), primary_key=True)  # Binary data in string field!
       binary_tag_id = Column(LargeBinary(16), nullable=False)  # Never populated
       user_id = Column(UUID, ForeignKey("users.id"))
   
   # After (proper separation of concerns)
   class SecretTag(Base, TimestampMixin):
       __tablename__ = "secret_tags"
       
       tag_id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
       phrase_hash = Column(LargeBinary(16), nullable=False, unique=True, index=True)
       user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
   ```

### Phase 3: Relationship Updates
1. **Update Relationship Definitions**
   - Ensure all relationships work with UUID primary keys
   - Update back_populates references
   - Verify cascade behaviors

2. **Validate Model Relationships**
   - Test model loading and relationships
   - Verify foreign key constraints
   - Check SQLAlchemy session functionality

### Phase 4: Import and Configuration Updates
1. **Update Import Statements**
   - Ensure proper UUID import in all model files
   - Add any missing type imports
   - Update __init__.py files as needed

2. **Configuration Validation**
   - Verify database configuration supports UUID
   - Check Alembic configuration
   - Validate model registration

## Test Plan

### Objective
Verify that all SQLAlchemy models work correctly with UUID primary keys and maintain all existing functionality.

### Test Environment
- Local development environment
- Test database with new UUID schema
- SQLAlchemy testing framework

### Key Test Scenarios

1. **Model Loading and Import**
   - All models import successfully
   - No circular import issues
   - SQLAlchemy can create all tables

2. **CRUD Operations**
   - Create operations work with UUID primary keys
   - Read operations handle UUID parameters
   - Update operations work with UUID identifiers
   - Delete operations work with UUID identifiers

3. **Relationship Testing**
   - Foreign key relationships work correctly
   - Eager loading works with UUID relationships
   - Cascade operations work properly
   - Back-reference relationships function

4. **Type Validation**
   - UUID values are properly validated
   - Type hints work correctly
   - SQLAlchemy type checking passes

### Success Criteria
- All models load without errors
- Basic CRUD operations work with UUID values
- Relationships function correctly
- No performance degradation
- Type hints and validation work properly

## Verification

### Completion Checklist
- [x] Journal Entry model converted to UUID primary key
- [x] Tag model converted to UUID primary key  
- [x] Reminder model converted to UUID primary key
- [x] User model UUID implementation verified
- [x] Monitoring model UUID implementation verified
- [x] All foreign key relationships updated
- [x] Model imports work correctly
- [x] Relationship definitions verified

### Technical Validation
- [x] `python -m backend.app.models` imports successfully
- [x] SQLAlchemy can create all tables
- [x] Basic model operations work with UUID values
- [x] Foreign key constraints are properly enforced
- [x] Type hints pass mypy validation

### Files Modified
- `backend/app/models/journal_entry.py` - UUID primary key conversion
- `backend/app/models/tag.py` - UUID primary key conversion
- `backend/app/models/reminder.py` - UUID primary key conversion
- `backend/app/models/user.py` - Verification and any needed updates
- `backend/app/models/monitoring.py` - Verification and any needed updates
- `backend/app/models/secret_tag_opaque.py` - SecretTag model restructure with `phrase_hash` column
- `backend/app/models/base.py` - Updated UUID type definition
- `backend/app/models/__init__.py` - Updated imports if needed

## Implementation Notes

### UUID Best Practices
1. **Primary Key Generation**: Use `uuid.uuid4()` for all new primary keys
2. **Foreign Key Types**: Use `UUID(as_uuid=True)` for all foreign key columns
3. **Nullable Constraints**: Add `nullable=False` to required foreign keys
4. **Default Values**: Set `default=uuid.uuid4` for primary key columns

### SQLAlchemy Considerations
1. **Type Handling**: Use `UUID(as_uuid=True)` for proper Python UUID handling
2. **Relationship Updates**: Verify all relationship() definitions work with UUID
3. **Index Strategy**: Prepare for index creation in subsequent tasks
4. **Performance**: UUID primary keys have different performance characteristics

### Dependencies
- Completion of Tasks 9-1 and 9-2 (schema migration and indexes)
- Python `uuid` module availability
- SQLAlchemy 2.0+ with UUID support
- Updated database schema with UUID primary keys

### Service Layer Updates Required
After model updates, the following service methods will need updates:
- `OpaqueService.register_secret_tag()` - Use separate UUID and phrase_hash
- `OpaqueService.authenticate_init()` - Query by phrase_hash instead of tag_id
- `SecretPhraseProcessor.find_matching_secret_tag()` - Use phrase_hash for lookups
- `JournalService.create_with_user()` - Handle UUID secret_tag_id references

### Risk Mitigation
- Test model loading in isolation first
- Validate relationships before proceeding
- Ensure proper type handling throughout
- Document any performance implications 