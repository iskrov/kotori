# [9-3] Add decryption error handling and recovery

## Description

Implement comprehensive error handling for decryption failures to ensure the app remains stable even when entries cannot be decrypted. This includes user-friendly error messages, recovery mechanisms, and logging for debugging.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-08-12 03:25:00 | Created | N/A | Proposed | Task created for error handling | ai-agent |

## Requirements

### Functional Requirements
1. Graceful degradation when decryption fails
2. User-friendly error messages
3. Ability to retry decryption
4. Option to view raw encrypted content (for debugging)
5. Automatic recovery attempts on app restart

### Technical Requirements
1. Structured error types for different failure modes
2. Retry logic with exponential backoff
3. Error reporting to backend (optional)
4. Local error log for debugging
5. Master key recovery mechanisms

## Implementation Plan

### Step 1: Define Error Types
```typescript
// Create new file: frontend/src/errors/encryptionErrors.ts
export enum DecryptionErrorType {
  MISSING_MASTER_KEY = 'MISSING_MASTER_KEY',
  INVALID_MASTER_KEY = 'INVALID_MASTER_KEY',
  CORRUPTED_ENTRY = 'CORRUPTED_ENTRY',
  MISSING_METADATA = 'MISSING_METADATA',
  CRYPTO_ERROR = 'CRYPTO_ERROR',
  UNKNOWN = 'UNKNOWN'
}

export class DecryptionError extends Error {
  constructor(
    public type: DecryptionErrorType,
    message: string,
    public entryId?: string,
    public canRetry: boolean = true,
    public originalError?: Error
  ) {
    super(message);
    this.name = 'DecryptionError';
  }
}
```

### Step 2: Implement Error Handler
```typescript
// Add to clientEncryption.ts
class DecryptionErrorHandler {
  private retryAttempts = new Map<string, number>();
  private maxRetries = 3;
  
  async handleDecryptionError(
    error: Error,
    entry: any,
    attemptRecovery: boolean = true
  ): Promise<string | null> {
    const entryId = entry.id;
    const attempts = this.retryAttempts.get(entryId) || 0;
    
    // Classify the error
    const decryptionError = this.classifyError(error, entry);
    
    // Log the error
    logger.error('Decryption failed', {
      entryId,
      errorType: decryptionError.type,
      attempts,
      error: error.message
    });
    
    // Attempt recovery if allowed
    if (attemptRecovery && decryptionError.canRetry && attempts < this.maxRetries) {
      this.retryAttempts.set(entryId, attempts + 1);
      
      switch (decryptionError.type) {
        case DecryptionErrorType.MISSING_MASTER_KEY:
          await this.recoverMasterKey();
          break;
        case DecryptionErrorType.INVALID_MASTER_KEY:
          await this.refreshMasterKey();
          break;
        default:
          // Wait before retry
          await this.delay(Math.pow(2, attempts) * 1000);
      }
      
      // Retry decryption
      try {
        return await this.retryDecryption(entry);
      } catch (retryError) {
        return this.handleDecryptionError(retryError, entry, false);
      }
    }
    
    // Return fallback content
    return this.getFallbackContent(decryptionError, entry);
  }
  
  private classifyError(error: Error, entry: any): DecryptionError {
    if (!entry.encrypted_content || !entry.encryption_iv) {
      return new DecryptionError(
        DecryptionErrorType.MISSING_METADATA,
        'Entry missing encryption metadata',
        entry.id,
        false
      );
    }
    
    if (error.message.includes('master key')) {
      return new DecryptionError(
        DecryptionErrorType.MISSING_MASTER_KEY,
        'Master key not available',
        entry.id,
        true,
        error
      );
    }
    
    if (error.message.includes('decrypt')) {
      return new DecryptionError(
        DecryptionErrorType.CRYPTO_ERROR,
        'Decryption operation failed',
        entry.id,
        true,
        error
      );
    }
    
    return new DecryptionError(
      DecryptionErrorType.UNKNOWN,
      error.message,
      entry.id,
      true,
      error
    );
  }
  
  private getFallbackContent(error: DecryptionError, entry: any): string {
    switch (error.type) {
      case DecryptionErrorType.MISSING_MASTER_KEY:
        return '[Content unavailable - Please log in again]';
      case DecryptionErrorType.CORRUPTED_ENTRY:
        return '[Content corrupted - Unable to decrypt]';
      case DecryptionErrorType.MISSING_METADATA:
        return '[Encryption metadata missing]';
      default:
        return '[Unable to decrypt content]';
    }
  }
}
```

### Step 3: Add Recovery Mechanisms
```typescript
// Add to clientEncryption.ts
async recoverMasterKey(): Promise<boolean> {
  try {
    // Try to get from OPAQUE session
    const opaqueKey = await this.getOpaqueExportKey();
    if (opaqueKey) {
      const masterKey = await this.deriveMasterKey(opaqueKey);
      await this.storeMasterKey(masterKey);
      return true;
    }
    
    // Try to get from secure storage backup
    const backupKey = await AsyncStorage.getItem('master_key_backup');
    if (backupKey) {
      // Verify and restore
      return true;
    }
    
    return false;
  } catch (error) {
    logger.error('Master key recovery failed', error);
    return false;
  }
}

async refreshMasterKey(): Promise<boolean> {
  try {
    // Clear existing key
    await AsyncStorage.removeItem(this.MASTER_KEY_STORAGE);
    
    // Re-derive from OPAQUE
    return await this.recoverMasterKey();
  } catch (error) {
    logger.error('Master key refresh failed', error);
    return false;
  }
}
```

### Step 4: Add UI Error Components
```typescript
// Create new component: frontend/src/components/DecryptionError.tsx
export const DecryptionErrorBanner: React.FC<{
  error: DecryptionError;
  onRetry: () => void;
  onDismiss: () => void;
}> = ({ error, onRetry, onDismiss }) => {
  return (
    <View style={styles.errorBanner}>
      <Text style={styles.errorText}>
        {getErrorMessage(error)}
      </Text>
      {error.canRetry && (
        <TouchableOpacity onPress={onRetry}>
          <Text style={styles.retryButton}>Retry</Text>
        </TouchableOpacity>
      )}
      <TouchableOpacity onPress={onDismiss}>
        <Text style={styles.dismissButton}>Dismiss</Text>
      </TouchableOpacity>
    </View>
  );
};
```

### Step 5: Add Error Reporting
```typescript
// Add to error handler
async reportError(error: DecryptionError): Promise<void> {
  if (error.type === DecryptionErrorType.CORRUPTED_ENTRY) {
    // Report to backend for investigation
    try {
      await api.post('/api/v1/errors/decryption', {
        entry_id: error.entryId,
        error_type: error.type,
        message: error.message,
        timestamp: new Date().toISOString()
      });
    } catch (reportError) {
      // Silently fail - don't break the app
      logger.error('Failed to report decryption error', reportError);
    }
  }
}
```

## Verification

### Test Scenarios
1. Simulate missing master key
2. Simulate corrupted encrypted content
3. Simulate missing encryption metadata
4. Test retry mechanism with temporary failures
5. Test error recovery on app restart
6. Test error UI components

### Success Criteria
- [ ] App doesn't crash on decryption failures
- [ ] Users see helpful error messages
- [ ] Retry mechanism works for transient failures
- [ ] Master key recovery works after re-login
- [ ] Error reporting helps identify issues

## Files Modified

Expected files to create/modify:
- `frontend/src/errors/encryptionErrors.ts` (new)
- `frontend/src/services/clientEncryption.ts`
- `frontend/src/components/DecryptionError.tsx` (new)
- `frontend/src/screens/main/JournalScreen.tsx`
- `frontend/src/screens/main/JournalEntryDetailScreen.tsx`

## Notes

This task ensures the app remains stable and user-friendly even when encryption/decryption issues occur. The error handling should be comprehensive but not intrusive to the user experience.

[Back to task list](./tasks.md)
