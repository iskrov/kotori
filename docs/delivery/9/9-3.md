# [9-3] Fix encryptedJournalService decryption flow

## Description

The encryptedJournalService currently has logic for secret tag decryption but needs to be updated to properly handle per-user encrypted entries. This task ensures the service correctly identifies and decrypts entries encrypted with the per-user encryption scheme.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-08-12 03:20:00 | Created | N/A | Proposed | Task created for service layer fixes | ai-agent |

## Requirements

### Functional Requirements
1. Detect per-user encrypted entries (is_encrypted flag + encrypted_content)
2. Decrypt using the correct key unwrapping process
3. Handle both legacy and new encryption formats
4. Provide clear API for components to use
5. Batch decryption for performance

### Technical Requirements
1. Update processEntries to handle per-user encryption
2. Implement decryptPerUser method in clientEncryption
3. Support both wrapped_key and encrypted_key field names
4. Handle missing or corrupted encryption metadata
5. Implement proper async/await patterns

## Implementation Plan

### Step 1: Update clientEncryption Service
```typescript
// Add to clientEncryption.ts
async decryptPerUser(encryptedData: {
  encrypted_content: string;
  encryption_iv: string;
  wrapped_key?: string;
  encrypted_key?: string; // legacy field name
  encryption_wrap_iv?: string;
  wrap_iv?: string; // alternate field name
}): Promise<string> {
  // Get master key from storage
  const masterKey = await this.getMasterKey();
  if (!masterKey) {
    throw new Error('No master key available for decryption');
  }

  // Get wrapped key (check both field names)
  const wrappedKeyB64 = encryptedData.wrapped_key || encryptedData.encrypted_key;
  if (!wrappedKeyB64) {
    throw new Error('No wrapped key found in encrypted data');
  }

  // Get wrap IV (check both field names)
  const wrapIvB64 = encryptedData.wrap_iv || encryptedData.encryption_wrap_iv;
  if (!wrapIvB64) {
    throw new Error('No wrap IV found in encrypted data');
  }

  // Unwrap the entry key
  const wrappedKey = this.base64ToArray(wrappedKeyB64);
  const wrapIv = this.base64ToArray(wrapIvB64);
  const entryKey = await this.unwrapEntryKey(wrappedKey, masterKey, wrapIv);

  // Decrypt the content
  const encryptedContent = this.base64ToArray(encryptedData.encrypted_content);
  const iv = this.base64ToArray(encryptedData.encryption_iv);
  
  const decrypted = await crypto.subtle.decrypt(
    { name: 'AES-GCM', iv },
    entryKey,
    encryptedContent
  );

  return new TextDecoder().decode(decrypted);
}
```

### Step 2: Update encryptedJournalService
```typescript
// Update processEntries method
async processEntries(entries: any[]): Promise<JournalEntryData[]> {
  const processed = await Promise.all(
    entries.map(async (entry) => {
      try {
        // Check for per-user encryption
        if (entry.is_encrypted && entry.encrypted_content) {
          const decryptedContent = await clientEncryption.decryptPerUser({
            encrypted_content: entry.encrypted_content,
            encryption_iv: entry.encryption_iv,
            wrapped_key: entry.wrapped_key,
            encrypted_key: entry.encrypted_key,
            wrap_iv: entry.wrap_iv,
            encryption_wrap_iv: entry.encryption_wrap_iv
          });
          
          return {
            ...entry,
            content: decryptedContent,
            // Clear sensitive fields from response
            encrypted_content: undefined,
            wrapped_key: undefined,
            encrypted_key: undefined
          };
        }
        
        // Return unencrypted entry as-is
        return entry;
      } catch (error) {
        logger.error('Failed to decrypt entry:', entry.id, error);
        return {
          ...entry,
          content: '[Unable to decrypt]',
          decryption_error: true
        };
      }
    })
  );
  
  return processed.filter(Boolean);
}
```

### Step 3: Add Batch Decryption Support
```typescript
// Add batch decryption for performance
async batchDecrypt(entries: any[]): Promise<any[]> {
  // Group encrypted and non-encrypted entries
  const encrypted = entries.filter(e => e.is_encrypted && e.encrypted_content);
  const unencrypted = entries.filter(e => !e.is_encrypted || !e.encrypted_content);
  
  // Decrypt in parallel with concurrency limit
  const BATCH_SIZE = 5;
  const decrypted = [];
  
  for (let i = 0; i < encrypted.length; i += BATCH_SIZE) {
    const batch = encrypted.slice(i, i + BATCH_SIZE);
    const results = await Promise.all(
      batch.map(entry => this.decryptEntry(entry).catch(err => ({
        ...entry,
        content: '[Decryption failed]',
        error: err.message
      })))
    );
    decrypted.push(...results);
  }
  
  return [...decrypted, ...unencrypted];
}
```

### Step 4: Update Type Definitions
```typescript
// Update types/index.ts
interface EncryptedEntry {
  encrypted_content: string;
  encryption_iv: string;
  wrapped_key?: string;
  encrypted_key?: string; // legacy
  wrap_iv?: string;
  encryption_wrap_iv?: string; // legacy
  is_encrypted: boolean;
}
```

## Verification

### Test Scenarios
1. Decrypt newly created encrypted entries
2. Decrypt existing encrypted entries (backward compatibility)
3. Handle mixed encrypted/unencrypted entry lists
4. Handle missing encryption metadata gracefully
5. Performance test with 50+ encrypted entries

### Success Criteria
- [ ] All per-user encrypted entries decrypt successfully
- [ ] Legacy encrypted entries (if any) still work
- [ ] Batch decryption improves performance
- [ ] Error handling prevents app crashes
- [ ] Decryption completes within 100ms per entry

## Files Modified

Expected files to modify:
- `frontend/src/services/clientEncryption.ts`
- `frontend/src/services/encryptedJournalService.ts`
- `frontend/src/types/index.ts`
- `frontend/src/services/api.ts` (if needed for type updates)

## Notes

This task is critical for making the encryption/decryption flow work properly. The implementation must handle various field name variations that might exist in the database while maintaining backward compatibility.

[Back to task list](./tasks.md)
