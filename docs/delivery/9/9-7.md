# [9-7] Document encryption architecture and key management

## Description

Create comprehensive technical documentation for the encryption system, including architecture diagrams, key management flows, security considerations, and operational procedures. This documentation is essential for maintaining and extending the system.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-08-12 03:45:00 | Created | N/A | Proposed | Task created for documentation | ai-agent |

## Requirements

### Functional Requirements
1. Document the complete encryption architecture
2. Explain key derivation and management flows
3. Provide security analysis and threat model
4. Include operational procedures
5. Create developer guide for extending the system

### Technical Requirements
1. Use Mermaid diagrams for visual flows
2. Include code examples
3. Document all cryptographic parameters
4. Provide troubleshooting guide
5. Include performance considerations

## Implementation Plan

### Step 1: Create Architecture Overview Document
```markdown
# Kotori Encryption Architecture

## Overview
Kotori implements client-side encryption to ensure user journal entries remain private. The system uses OPAQUE for authentication and derives encryption keys from the OPAQUE export key.

## Core Principles
1. **Zero-Knowledge**: Server never sees plaintext content
2. **Per-User Encryption**: Each user has a unique master key
3. **Per-Entry Keys**: Each entry encrypted with unique key
4. **Forward Secrecy**: Compromised keys don't affect past entries

## Architecture Components

### 1. Authentication Layer (OPAQUE)
- Password-authenticated key exchange
- Export key generation
- No password stored on server

### 2. Key Derivation Layer
- Master key derived from OPAQUE export key
- Uses HKDF-SHA256 for key derivation
- Deterministic but cryptographically secure

### 3. Encryption Layer
- AES-256-GCM for content encryption
- Per-entry key generation
- Key wrapping with master key

### 4. Storage Layer
- Encrypted content stored on server
- Keys stored in client secure storage
- Metadata for key recovery
```

### Step 2: Create Key Management Flow Diagram
```mermaid
# Add to docs/technical/encryption-flows.md

sequenceDiagram
    participant User
    participant App
    participant OPAQUE
    participant KeyService
    participant Storage
    participant Server

    User->>App: Login with password
    App->>OPAQUE: Authenticate
    OPAQUE-->>App: Session + Export Key
    
    App->>KeyService: Derive master key
    Note over KeyService: HKDF(export_key, salt, info)
    KeyService-->>App: Master Key
    
    App->>Storage: Store master key securely
    
    User->>App: Create journal entry
    App->>KeyService: Generate entry key
    Note over KeyService: Generate random AES key
    
    App->>KeyService: Encrypt content
    Note over KeyService: AES-GCM encrypt
    
    App->>KeyService: Wrap entry key
    Note over KeyService: AES-KW with master key
    
    App->>Server: Store encrypted entry
    Note over Server: Stores encrypted_content,<br/>wrapped_key, iv, etc.
    
    User->>App: View journal entry
    App->>Server: Fetch encrypted entry
    Server-->>App: Encrypted data
    
    App->>Storage: Get master key
    Storage-->>App: Master Key
    
    App->>KeyService: Unwrap entry key
    App->>KeyService: Decrypt content
    KeyService-->>App: Plaintext content
    App->>User: Display entry
```

### Step 3: Document Cryptographic Details
```markdown
# Cryptographic Specifications

## Algorithms and Parameters

### Key Derivation
- **Algorithm**: HKDF-SHA256
- **Input Key**: OPAQUE export key (256 bits)
- **Salt**: Application-specific constant
- **Info**: User ID + context string
- **Output**: 256-bit master key

### Content Encryption
- **Algorithm**: AES-256-GCM
- **Key Size**: 256 bits
- **IV Size**: 96 bits (12 bytes)
- **Tag Size**: 128 bits (16 bytes)
- **Random IV**: Generated per encryption

### Key Wrapping
- **Algorithm**: AES-KW (RFC 3394)
- **Wrapper Key**: User's master key
- **Wrapped Key**: Per-entry AES key
- **IV**: Random 96-bit value

## Security Properties

### Confidentiality
- Content encrypted with AES-256-GCM
- Keys never transmitted in plaintext
- Server has no access to keys

### Integrity
- GCM provides authenticated encryption
- Tampering detected via authentication tag
- Wrapped keys integrity protected

### Forward Secrecy
- Random per-entry keys
- Key rotation capability
- Old keys can be deleted

## Threat Model

### In Scope
- Server compromise
- Network eavesdropping
- Database breach
- Malicious administrator

### Out of Scope
- Client device compromise
- Keyloggers
- Physical access to device
- Side-channel attacks
```

### Step 4: Create Operational Procedures
```markdown
# Operational Procedures

## Key Recovery Procedures

### Scenario 1: User Forgot Password
1. User must reset password via OPAQUE
2. New export key generated
3. Old encrypted entries become inaccessible
4. Option to restore from backup if available

### Scenario 2: Lost Device
1. Login on new device
2. OPAQUE authentication provides export key
3. Master key re-derived
4. All entries accessible again

### Scenario 3: Corrupted Key Storage
1. Clear local key storage
2. Re-authenticate with OPAQUE
3. Keys automatically recovered
4. Verify entry decryption

## Key Rotation Procedure

### When to Rotate
- Suspected key compromise
- Regular security maintenance (yearly)
- Before major updates

### Rotation Steps
1. Generate new master key
2. Decrypt all entries with old key
3. Re-encrypt with new key
4. Update all entries atomically
5. Archive old key (encrypted)
6. Verify all entries decrypt

## Backup and Recovery

### Creating Backups
1. Export master key (encrypted)
2. Include metadata (timestamp, version)
3. Store in secure location
4. Test restoration procedure

### Restoring from Backup
1. Import backup file
2. Decrypt with backup password
3. Verify key integrity
4. Test with known entry
5. Update key metadata
```

### Step 5: Create Developer Guide
```markdown
# Developer Guide

## Adding Encryption to New Features

### Example: Encrypting User Settings
```typescript
// 1. Define encrypted data structure
interface EncryptedSettings {
  encrypted_data: string;
  encryption_iv: string;
  wrapped_key: string;
  wrap_iv: string;
}

// 2. Implement encryption
async function encryptSettings(settings: UserSettings): Promise<EncryptedSettings> {
  const plaintext = JSON.stringify(settings);
  const encrypted = await clientEncryption.encryptPerUser(plaintext);
  
  return {
    encrypted_data: encrypted.encryptedContent,
    encryption_iv: encrypted.iv,
    wrapped_key: encrypted.wrappedKey,
    wrap_iv: encrypted.wrapIv
  };
}

// 3. Implement decryption
async function decryptSettings(encrypted: EncryptedSettings): Promise<UserSettings> {
  const plaintext = await clientEncryption.decryptPerUser({
    encrypted_content: encrypted.encrypted_data,
    encryption_iv: encrypted.encryption_iv,
    wrapped_key: encrypted.wrapped_key,
    wrap_iv: encrypted.wrap_iv
  });
  
  return JSON.parse(plaintext);
}
```

## Testing Encryption

### Unit Tests
- Test key derivation determinism
- Test encryption/decryption round trip
- Test error handling
- Test key wrapping

### Integration Tests
- Test with real OPAQUE flow
- Test with actual storage
- Test error recovery
- Test performance

## Performance Considerations

### Optimization Strategies
1. **Batch Operations**: Encrypt/decrypt multiple items together
2. **Caching**: Cache decrypted content with LRU eviction
3. **Web Workers**: Offload crypto operations
4. **Streaming**: For large content, use streaming encryption

### Benchmarks
- Small entry (< 1KB): < 10ms
- Medium entry (10KB): < 50ms
- Large entry (100KB): < 200ms
- Batch of 20 entries: < 500ms

## Security Best Practices

### DO
- Always use crypto.getRandomValues() for IVs
- Verify authentication tags
- Clear keys from memory after use
- Use constant-time comparisons
- Log security events

### DON'T
- Reuse IVs
- Store keys in plaintext
- Ignore decryption failures
- Use weak random sources
- Log sensitive data
```

### Step 6: Create Troubleshooting Guide
```markdown
# Troubleshooting Guide

## Common Issues

### Issue: "No content" displayed for entries
**Symptoms**: Entries show only title, content is empty
**Cause**: Decryption not happening on client
**Solution**:
1. Check if master key is available
2. Verify entry has encryption fields
3. Check console for decryption errors
4. Try key recovery procedure

### Issue: Decryption fails with "Invalid key"
**Symptoms**: Error when trying to decrypt
**Cause**: Wrong master key or corrupted data
**Solution**:
1. Clear local key storage
2. Re-login to derive new key
3. If persists, restore from backup
4. Contact support with entry ID

### Issue: Slow performance with many entries
**Symptoms**: List takes long to load
**Cause**: Sequential decryption without cache
**Solution**:
1. Enable decryption cache
2. Implement batch decryption
3. Use pagination for large lists
4. Check cache hit rate

## Debugging Tools

### Key Verification
```typescript
// Verify master key is available
const hasKey = await clientEncryption.hasMasterKey();
console.log('Master key available:', hasKey);

// Test encryption/decryption
const test = await clientEncryption.testEncryption();
console.log('Encryption test:', test);
```

### Cache Statistics
```typescript
// Check cache performance
const stats = decryptionCache.getStats();
console.log('Cache stats:', stats);
```

### Entry Inspection
```typescript
// Check if entry is encrypted
console.log('Is encrypted:', entry.is_encrypted);
console.log('Has encrypted content:', !!entry.encrypted_content);
console.log('Has wrapped key:', !!entry.wrapped_key);
```

## Support Procedures

### Information to Collect
1. User ID (not password)
2. Entry IDs that fail
3. Browser/app version
4. Console error logs
5. Time of occurrence

### Escalation Path
1. Check troubleshooting guide
2. Review error logs
3. Test in development environment
4. Escalate to security team if needed
```

### Step 7: Create Security Audit Checklist
```markdown
# Security Audit Checklist

## Quarterly Review
- [ ] Review all cryptographic libraries for updates
- [ ] Check for known vulnerabilities
- [ ] Audit key storage mechanisms
- [ ] Review access logs
- [ ] Test key recovery procedures
- [ ] Verify backup integrity

## Code Review Checklist
- [ ] No hardcoded keys or secrets
- [ ] Proper IV generation (random)
- [ ] Error messages don't leak information
- [ ] Keys cleared from memory
- [ ] Proper authentication tag verification
- [ ] Constant-time comparisons used

## Deployment Checklist
- [ ] Environment variables set correctly
- [ ] Secure storage configured
- [ ] HTTPS enforced
- [ ] CSP headers configured
- [ ] Key rotation scheduled
- [ ] Monitoring alerts active
```

## Verification

### Documentation Review
1. Technical accuracy verified
2. Code examples tested
3. Diagrams render correctly
4. Links work
5. Procedures validated

### Success Criteria
- [ ] Architecture clearly documented
- [ ] All flows diagrammed
- [ ] Security model explained
- [ ] Procedures actionable
- [ ] Troubleshooting comprehensive

## Files Modified

Expected files to create:
- `docs/technical/encryption-architecture.md` (new)
- `docs/technical/encryption-flows.md` (new)
- `docs/technical/key-management.md` (new)
- `docs/technical/encryption-operations.md` (new)
- `docs/technical/encryption-developer-guide.md` (new)
- `docs/technical/encryption-troubleshooting.md` (new)
- `docs/technical/security-audit-checklist.md` (new)

## Notes

This documentation is critical for maintaining the security and reliability of the encryption system. It should be kept up-to-date as the system evolves and reviewed regularly by the security team.

[Back to task list](./tasks.md)
