# [9-7] Create integration tests for encryption/decryption flow

## Description

Implement comprehensive integration tests to ensure the complete encryption/decryption flow works correctly end-to-end. This includes testing the interaction between OPAQUE authentication, key derivation, encryption, storage, and decryption.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-08-12 03:40:00 | Created | N/A | Proposed | Task created for integration testing | ai-agent |

## Requirements

### Functional Requirements
1. Test complete user journey from login to viewing encrypted entries
2. Test key derivation from OPAQUE export keys
3. Test encryption during entry creation
4. Test decryption during entry retrieval
5. Test error scenarios and recovery

### Technical Requirements
1. Use Jest for test framework
2. Mock OPAQUE authentication responses
3. Test with real crypto operations (not mocked)
4. Test across different platforms (web, iOS, Android)
5. Performance benchmarks included

## Implementation Plan

### Step 1: Setup Test Infrastructure
```typescript
// Create new file: frontend/src/__tests__/integration/encryption.test.ts
import { OPAQUEClient } from '@serenity-kit/opaque';
import { clientEncryption } from '../../services/clientEncryption';
import { encryptedJournalService } from '../../services/encryptedJournalService';
import { mockAsyncStorage } from '../mocks/asyncStorage';

describe('Encryption/Decryption Integration Tests', () => {
  let opaqueClient: OPAQUEClient;
  let testUser: TestUser;
  
  beforeAll(async () => {
    // Setup OPAQUE client
    opaqueClient = new OPAQUEClient();
    await opaqueClient.initialize();
    
    // Setup test user
    testUser = {
      username: 'test@example.com',
      password: 'TestPassword123!',
      export_key: null
    };
    
    // Mock AsyncStorage
    jest.mock('@react-native-async-storage/async-storage', () => mockAsyncStorage);
  });
  
  afterEach(async () => {
    // Clear storage between tests
    await mockAsyncStorage.clear();
    jest.clearAllMocks();
  });
});
```

### Step 2: Test OPAQUE Key Derivation
```typescript
describe('OPAQUE Key Derivation', () => {
  test('should derive master key from OPAQUE export key', async () => {
    // Simulate OPAQUE login
    const loginResult = await simulateOPAQUELogin(testUser);
    expect(loginResult.export_key).toBeDefined();
    
    // Store export key
    testUser.export_key = loginResult.export_key;
    
    // Derive master key
    const masterKey = await clientEncryption.deriveKeyFromOPAQUE(
      loginResult.export_key
    );
    
    expect(masterKey).toBeDefined();
    expect(masterKey.type).toBe('secret');
    expect(masterKey.algorithm.name).toBe('AES-GCM');
    expect(masterKey.algorithm.length).toBe(256);
  });
  
  test('should consistently derive same key from same export key', async () => {
    const exportKey = testUser.export_key;
    
    const key1 = await clientEncryption.deriveKeyFromOPAQUE(exportKey);
    const key2 = await clientEncryption.deriveKeyFromOPAQUE(exportKey);
    
    // Export to compare
    const exported1 = await crypto.subtle.exportKey('raw', key1);
    const exported2 = await crypto.subtle.exportKey('raw', key2);
    
    expect(new Uint8Array(exported1)).toEqual(new Uint8Array(exported2));
  });
  
  test('should derive different keys for different users', async () => {
    const user1Export = 'export_key_user_1';
    const user2Export = 'export_key_user_2';
    
    const key1 = await clientEncryption.deriveKeyFromOPAQUE(user1Export);
    const key2 = await clientEncryption.deriveKeyFromOPAQUE(user2Export);
    
    const exported1 = await crypto.subtle.exportKey('raw', key1);
    const exported2 = await crypto.subtle.exportKey('raw', key2);
    
    expect(new Uint8Array(exported1)).not.toEqual(new Uint8Array(exported2));
  });
});
```

### Step 3: Test Entry Encryption Flow
```typescript
describe('Entry Encryption', () => {
  let masterKey: CryptoKey;
  
  beforeEach(async () => {
    // Setup master key
    masterKey = await clientEncryption.deriveKeyFromOPAQUE(testUser.export_key);
    await clientEncryption.storeMasterKey(masterKey);
  });
  
  test('should encrypt journal entry content', async () => {
    const entryData = {
      title: 'Test Entry',
      content: 'This is my private journal content',
      entry_date: new Date().toISOString(),
      tags: ['test']
    };
    
    const encrypted = await encryptedJournalService.createEntry(entryData);
    
    expect(encrypted.encrypted_content).toBeDefined();
    expect(encrypted.encryption_iv).toBeDefined();
    expect(encrypted.wrapped_key).toBeDefined();
    expect(encrypted.wrap_iv).toBeDefined();
    expect(encrypted.content).toBe(''); // Server should not see plaintext
  });
  
  test('should generate unique encryption for each entry', async () => {
    const content = 'Same content for both entries';
    
    const encrypted1 = await clientEncryption.encryptPerUser(content);
    const encrypted2 = await clientEncryption.encryptPerUser(content);
    
    // Same content should produce different encrypted results
    expect(encrypted1.encryptedContent).not.toBe(encrypted2.encryptedContent);
    expect(encrypted1.iv).not.toBe(encrypted2.iv);
    expect(encrypted1.wrappedKey).not.toBe(encrypted2.wrappedKey);
  });
  
  test('should handle large content encryption', async () => {
    const largeContent = 'x'.repeat(100000); // 100KB of content
    
    const startTime = Date.now();
    const encrypted = await clientEncryption.encryptPerUser(largeContent);
    const encryptTime = Date.now() - startTime;
    
    expect(encrypted.encryptedContent).toBeDefined();
    expect(encryptTime).toBeLessThan(1000); // Should complete within 1 second
  });
});
```

### Step 4: Test Entry Decryption Flow
```typescript
describe('Entry Decryption', () => {
  let masterKey: CryptoKey;
  let encryptedEntry: any;
  
  beforeEach(async () => {
    masterKey = await clientEncryption.deriveKeyFromOPAQUE(testUser.export_key);
    await clientEncryption.storeMasterKey(masterKey);
    
    // Create an encrypted entry
    const content = 'Test journal content for decryption';
    const encrypted = await clientEncryption.encryptPerUser(content);
    
    encryptedEntry = {
      id: 'test-entry-1',
      title: 'Test Entry',
      content: '', // Empty as returned by server
      encrypted_content: encrypted.encryptedContent,
      encryption_iv: encrypted.iv,
      wrapped_key: encrypted.wrappedKey,
      wrap_iv: encrypted.wrapIv,
      is_encrypted: true,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };
  });
  
  test('should decrypt encrypted entry content', async () => {
    const decrypted = await encryptedJournalService.processEntries([encryptedEntry]);
    
    expect(decrypted).toHaveLength(1);
    expect(decrypted[0].content).toBe('Test journal content for decryption');
    expect(decrypted[0].encrypted_content).toBeUndefined(); // Should be removed
  });
  
  test('should handle batch decryption', async () => {
    const entries = [];
    for (let i = 0; i < 20; i++) {
      const encrypted = await clientEncryption.encryptPerUser(`Content ${i}`);
      entries.push({
        id: `entry-${i}`,
        title: `Entry ${i}`,
        content: '',
        encrypted_content: encrypted.encryptedContent,
        encryption_iv: encrypted.iv,
        wrapped_key: encrypted.wrappedKey,
        wrap_iv: encrypted.wrapIv,
        is_encrypted: true
      });
    }
    
    const startTime = Date.now();
    const decrypted = await encryptedJournalService.processEntries(entries);
    const decryptTime = Date.now() - startTime;
    
    expect(decrypted).toHaveLength(20);
    decrypted.forEach((entry, i) => {
      expect(entry.content).toBe(`Content ${i}`);
    });
    expect(decryptTime).toBeLessThan(2000); // Should complete within 2 seconds
  });
  
  test('should handle mixed encrypted/unencrypted entries', async () => {
    const mixedEntries = [
      encryptedEntry,
      {
        id: 'plain-entry',
        title: 'Plain Entry',
        content: 'This is not encrypted',
        is_encrypted: false
      },
      encryptedEntry
    ];
    
    const processed = await encryptedJournalService.processEntries(mixedEntries);
    
    expect(processed).toHaveLength(3);
    expect(processed[0].content).toBe('Test journal content for decryption');
    expect(processed[1].content).toBe('This is not encrypted');
    expect(processed[2].content).toBe('Test journal content for decryption');
  });
});
```

### Step 5: Test Error Scenarios
```typescript
describe('Error Handling', () => {
  test('should handle missing master key gracefully', async () => {
    // Clear any stored keys
    await AsyncStorage.clear();
    
    const entry = {
      id: 'test-entry',
      encrypted_content: 'encrypted_data',
      encryption_iv: 'iv_data',
      wrapped_key: 'wrapped_key',
      is_encrypted: true
    };
    
    const processed = await encryptedJournalService.processEntries([entry]);
    
    expect(processed[0].content).toContain('[');
    expect(processed[0].content).toContain(']');
    expect(processed[0].decryption_error).toBe(true);
  });
  
  test('should handle corrupted encrypted content', async () => {
    const masterKey = await clientEncryption.deriveKeyFromOPAQUE(testUser.export_key);
    await clientEncryption.storeMasterKey(masterKey);
    
    const entry = {
      id: 'corrupted-entry',
      encrypted_content: 'CORRUPTED_BASE64_@#$%',
      encryption_iv: 'valid_iv',
      wrapped_key: 'valid_key',
      is_encrypted: true
    };
    
    const processed = await encryptedJournalService.processEntries([entry]);
    
    expect(processed[0].content).toContain('[');
    expect(processed[0].decryption_error).toBe(true);
  });
  
  test('should recover from transient failures', async () => {
    let attempts = 0;
    const originalDecrypt = clientEncryption.decryptPerUser;
    
    // Mock to fail first 2 times, succeed on 3rd
    clientEncryption.decryptPerUser = jest.fn().mockImplementation(async (data) => {
      attempts++;
      if (attempts < 3) {
        throw new Error('Transient failure');
      }
      return originalDecrypt.call(clientEncryption, data);
    });
    
    const entry = createValidEncryptedEntry();
    const processed = await encryptedJournalService.processEntries([entry]);
    
    expect(attempts).toBe(3);
    expect(processed[0].content).toBe('Test content');
    
    clientEncryption.decryptPerUser = originalDecrypt;
  });
});
```

### Step 6: Test Key Persistence
```typescript
describe('Key Persistence', () => {
  test('should persist master key across sessions', async () => {
    // First session - derive and store key
    const exportKey = testUser.export_key;
    const masterKey1 = await clientEncryption.deriveKeyFromOPAQUE(exportKey);
    await clientEncryption.storeMasterKey(masterKey1);
    
    // Simulate app restart
    clientEncryption.clearMemoryCache();
    
    // Second session - retrieve stored key
    const masterKey2 = await clientEncryption.getMasterKey();
    
    expect(masterKey2).toBeDefined();
    
    // Verify keys are the same
    const testData = 'test encryption data';
    const encrypted1 = await encrypt(testData, masterKey1);
    const decrypted2 = await decrypt(encrypted1, masterKey2);
    
    expect(decrypted2).toBe(testData);
  });
  
  test('should recover key from OPAQUE if not in storage', async () => {
    // Clear storage
    await AsyncStorage.clear();
    
    // Mock OPAQUE session
    mockOPAQUESession(testUser.export_key);
    
    // Try to get master key (should trigger recovery)
    const masterKey = await clientEncryption.getMasterKey();
    
    expect(masterKey).toBeDefined();
    
    // Verify it's stored for next time
    const stored = await AsyncStorage.getItem('master_key');
    expect(stored).toBeDefined();
  });
});
```

### Step 7: Performance Benchmarks
```typescript
describe('Performance Benchmarks', () => {
  test('encryption performance', async () => {
    const sizes = [1000, 10000, 100000]; // 1KB, 10KB, 100KB
    const results = [];
    
    for (const size of sizes) {
      const content = 'x'.repeat(size);
      const iterations = 10;
      let totalTime = 0;
      
      for (let i = 0; i < iterations; i++) {
        const start = performance.now();
        await clientEncryption.encryptPerUser(content);
        totalTime += performance.now() - start;
      }
      
      const avgTime = totalTime / iterations;
      results.push({ size, avgTime });
      
      // Performance expectations
      expect(avgTime).toBeLessThan(size / 100); // ~100KB/s minimum
    }
    
    console.table(results);
  });
  
  test('decryption performance with cache', async () => {
    const entries = await createEncryptedEntries(50);
    
    // First pass - no cache
    const start1 = performance.now();
    await encryptedJournalService.processEntries(entries);
    const time1 = performance.now() - start1;
    
    // Second pass - with cache
    const start2 = performance.now();
    await encryptedJournalService.processEntries(entries);
    const time2 = performance.now() - start2;
    
    // Cache should make it 10x faster
    expect(time2).toBeLessThan(time1 / 10);
    
    console.log(`No cache: ${time1}ms, With cache: ${time2}ms`);
  });
});
```

## Verification

### Test Coverage Requirements
- [ ] 90% code coverage for encryption services
- [ ] All critical paths tested
- [ ] Error scenarios covered
- [ ] Performance benchmarks passing

### CI/CD Integration
```yaml
# Add to CI pipeline
- name: Run Encryption Integration Tests
  run: |
    npm test -- --testPathPattern=encryption.test.ts --coverage
    npm run test:performance
```

### Success Criteria
- [ ] All tests passing consistently
- [ ] No flaky tests
- [ ] Performance within acceptable limits
- [ ] Works across all platforms
- [ ] Memory leaks detected and fixed

## Files Modified

Expected files to create/modify:
- `frontend/src/__tests__/integration/encryption.test.ts` (new)
- `frontend/src/__tests__/mocks/asyncStorage.ts` (new)
- `frontend/src/__tests__/mocks/opaque.ts` (new)
- `frontend/src/__tests__/helpers/encryption.ts` (new)
- `frontend/jest.config.js` (update)
- `frontend/package.json` (add test scripts)

## Notes

These integration tests are crucial for ensuring the encryption system works correctly end-to-end. They should be run on every commit and before any release. Performance benchmarks help ensure the system remains responsive as the codebase evolves.

[Back to task list](./tasks.md)
